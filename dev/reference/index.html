<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · JetPack</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JetPack</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">JetPack</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/JetPack.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopAtan-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T" href="#JetPack.JopAtan-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T"><code>JetPack.JopAtan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopAtan(spc, c)</code></pre><p>where <code>F</code> is the shifted arc tangent operator F = arctan( x(t)/c ) + π/2 </p><p>x(t) = 0 corresponds to F = π/2 if |x(t)| ≤ c, then π/4 ≤ F ≤ 3π/4</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_atan.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopBlend" href="#JetPack.JopBlend"><code>JetPack.JopBlend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">A = JotOpBlend(T, nsamples, shottimes[, nsamples_blended])</code></pre><p>where <code>A</code> is a shot mixing operation, so that if <code>d=Am</code>, then <code>m::Array{T,2}</code> is a common receiver gather with each trace corresponding to a different shot.  The excitation time of each are the entries of <code>shottimes::Array{Int,1}</code> in units of time samples.  The size of <code>m</code> is <code>(nsamples,length(shottimes))</code>.  The size of <code>d</code> is either <code>nsamples_blended</code> (if provided) or <code>maximum(shot_times)+nsamples-1</code>.</p><p><strong>Examples</strong></p><p><strong>blend two receiver gather traces:</strong></p><pre><code class="language-julia">A = JotOpBlend(Float64, 128, [1,64])
m = rand(domain(A))
d = A*m # receiver gather with blended shots</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_blend.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopCircShift-Tuple{Any,Any}" href="#JetPack.JopCircShift-Tuple{Any,Any}"><code>JetPack.JopCircShift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopCircShift(R::JetSpace, shifts)</code></pre><p><code>d=A*m</code> is equivalent to <code>circshift(d, m, shifts)</code>, and where <code>m</code> and <code>d</code> are in the domain/range of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_circshift.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopDerivative-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T" href="#JetPack.JopDerivative-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopDerivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopDerivative(R::JetSpace[; dim=1, accuracy=4, delta=1.0)</code></pre><p><code>A*m</code> is the centered finite different approximation to the derivative of <code>m</code> along dimension <code>dim</code>.  The <code>accuracy</code> of the approximation is either <code>4</code> for a 4th order accurate estimate of the derivative, or <code>8</code> for an 8th order accurate derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_derivative.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopDiagonal-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T" href="#JetPack.JopDiagonal-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopDiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A = JopDiagonal(spc, d) A = JopDiagonal(d)</p><p>where <code>spc::JetSpace</code> is the domain/range of <code>A</code>, and <code>d::Array</code> or <code>d::Number</code> is the diagonal.  If <code>d&lt;:Number</code>, then the diagonal of the matrix is constant and one must specify <code>spc</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">A = JopDiagonal(spc, d)</code></pre><p>where <code>spc::JetSpace</code> is the domain and range of <code>A</code>, and <code>d&lt;:Array</code> or <code>d&lt;:Number</code></p><pre><code class="language-julia">A = JotOpDiagonal(d)</code></pre><p>where <code>d&lt;:AbstractArray</code>.  The domain and range of <code>A</code> are determined by the size and type of <code>d</code>.</p><pre><code class="language-julia">A = JotOpDiagonal([1.0, 2.0, 3.0])
m = ones(domain(A))
d = A*m # d = [1.0 ; 2.0 ; 3.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_diagonal.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopDifference" href="#JetPack.JopDifference"><code>JetPack.JopDifference</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">A = JopDifference(R::JetSpace[, dim=1])</code></pre><p><code>A*m</code> is similar to <code>diff(a,dims=dim)</code> where <code>a</code> is a vector in the space <code>R</code>. In other words, it is the one-sided difference of <code>a</code> along the dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_difference.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopExp-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T" href="#JetPack.JopExp-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T"><code>JetPack.JopExp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopExp(spc, c)</code></pre><p>where <code>F</code> is the exponential operator e^(c/x) with domain and range given by <code>spc::JetSpace</code>, and scalar value c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_exp.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopGradient-Union{Tuple{N}, Tuple{T}, Tuple{Jets.JetSpace{T,N},Tuple{Vararg{T,N}}}} where N where T" href="#JetPack.JopGradient-Union{Tuple{N}, Tuple{T}, Tuple{Jets.JetSpace{T,N},Tuple{Vararg{T,N}}}} where N where T"><code>JetPack.JopGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopGradient(dom, δ)</code></pre><p>Gradient for a 2D or 3D arrays. The range will have one more dimension than the domain and contain the components of the gradient in each dimension.</p><ul><li><code>dom::JetSpace{T,N}</code> is the domain of the operator.</li><li><code>δ::NTuple{T,N}</code> is the grid spacing in each dimension.</li></ul><p><strong>Examples:</strong></p><p><strong>2D</strong></p><pre><code class="language-julia">nz,nx = 11,12
dom = JetSpace(Float32, nz, nx)
A = JopGradient(dom, (1.0,1.0))
size(domain(A)) # (11,12)
size(range(A))  # (11,12,2)</code></pre><p><strong>3D</strong></p><pre><code class="language-julia">nz,ny,nx = 11,12,13
dom = JetSpace(Float32, nz, ny, nx)
A = JopGradient(dom,(1.0,1.0,1.0))
size(domain(A)) # (11,12,13)
size(range(A))  # (11,12,13,3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_gradient.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopHighpass-Tuple{Jets.JetSpace}" href="#JetPack.JopHighpass-Tuple{Jets.JetSpace}"><code>JetPack.JopHighpass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopHighpass(sp)</code></pre><p>Build a 2D Highpass operator, which first apply a center weighted three point smoothing operator [0.25, 0.5, 0.25] to each dimension with a given iterations number (nit[1:2]) to get the low frequency component of the data, then subtract it from the original data to return the high pass component.  It works with <code>sp::JetSpace</code>, <code>nit::Array{Integer, 1}</code> and <code>A::JopHighpass</code>.  It can specify different number of iterations (nit) in x and z direction. For a seismic image, more iterations in z direction is often applied to obtain more vertical resolution.</p><p>For example,</p><pre><code class="language-julia">A = JopHighpass(JetSpace(Float64,128,256), nit=(3,1)])
m = rand(domain(A))
d = A*m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_highpass.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopImag-Union{Tuple{Jets.JetSpace{Complex{T},N} where N}, Tuple{T}} where T" href="#JetPack.JopImag-Union{Tuple{Jets.JetSpace{Complex{T},N} where N}, Tuple{T}} where T"><code>JetPack.JopImag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">op = JopImag(dom)</code></pre><p>Extract the imaginary part of a complex input array where <code>dom::JetSpace{&lt;:Complex}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_imag.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopInterp-Tuple{Jets.JetAbstractSpace,Jets.JetAbstractSpace}" href="#JetPack.JopInterp-Tuple{Jets.JetAbstractSpace,Jets.JetAbstractSpace}"><code>JetPack.JopInterp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopInterp(dom, rng)</code></pre><p>Performs linear interpolation from dom::JetSpace to rng::JetSpace. It is often used to reduce dimensionality in FWI.  JopInterp is ported from the CVX frequency domain FWI tools in SeisSpace.</p><p><strong>Notes</strong></p><ul><li>It is required that domain and range have the same dimensionality.</li><li>It is required that domain and range both have more than 2 points per dimension</li><li>It is required that the domain is coarser than the range.</li><li>It is assumed that domain and range have the same boundary (e.g. in 2D: xmin,xmax,zmin,zmax).</li></ul><p><strong>Examples:</strong></p><p><strong>2D</strong></p><pre><code class="language-julia">dom = JetSpace(Float32, 11, 11)
rng = JetSpace(Float32, 23, 23)
A = JopInterp(dom, rng)
y = A * rand(dom)
x = A&#39; * rand(rng)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_interp.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopLMO-Union{Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any,Any,Any}} where T" href="#JetPack.JopLMO-Union{Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any,Any,Any}} where T"><code>JetPack.JopLMO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopLMO(spc [;v=2.0, dx=1.0, dt=1.0])</code></pre><p>2D linear moveout operator for domain and range <code>sp::JetSpace</code>.  The forward operator maps from flat events to dipping events using the parameters <code>v,dx,dt</code>, and:</p><pre><code class="language-none">(z_moveout) = (z + (dx/dt)/v * x)</code></pre><p><strong>Notes</strong></p><ul><li>It should be trivial to add a 3D implementation for this operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_lmo.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopLaplacian-Tuple{Jets.JetSpace}" href="#JetPack.JopLaplacian-Tuple{Jets.JetSpace}"><code>JetPack.JopLaplacian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopLaplacian(sp)</code></pre><p>Build a 2D (d^2/dx^2+d^2/dy^2) or 3D (d^2/dx^2+d^2/dy^2+d^2/dz^2) Laplacian operator with three point centered finite difference stencil, with <code>sp::JetSpace</code> and <code>A::JopLaplacian</code>.</p><p>For example,</p><pre><code class="language-julia">A = JopLaplacian(JetSpace(Float64,128,256))
m = rand(domain(A))
d = A*m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_laplacian.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopLog-Tuple{Jets.JetSpace}" href="#JetPack.JopLog-Tuple{Jets.JetSpace}"><code>JetPack.JopLog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopLog(spc)</code></pre><p>where <code>F</code> is the log operator with domain and range given by <code>spc::JetSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_log.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopMix-Union{Tuple{N}, Tuple{T}, Tuple{Jets.JetAbstractSpace{T,N},Tuple{Vararg{Int64,N}}}} where N where T" href="#JetPack.JopMix-Union{Tuple{N}, Tuple{T}, Tuple{Jets.JetAbstractSpace{T,N},Tuple{Vararg{Int64,N}}}} where N where T"><code>JetPack.JopMix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopMix(s::JetAbstractSpace{T,N}, nmix::NTuple{N,Int})</code></pre><p>2D spatial mix, and is used to add smoothness to a domain.  JopMix is ported from the CVX frequency domain FWI tools in SeisSpace.</p><p><strong>Notes:</strong></p><ul><li>This appears to over-lap in funtionality with JopRoughness.</li></ul><p><strong>Examples:</strong></p><p><strong>2D</strong></p><pre><code class="language-julia">nz, nx = 11,11
spc = JetSpace(Float32, nz, nx)
A = JopMix(spc, (5,5))
y = A * rand(dom)
x = A&#39; * rand(rng)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_mix.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopNim-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T" href="#JetPack.JopNim-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopNim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopNim(spc, c)</code></pre><p>where <code>F</code> is the &#39;normalized integral method&#39; operator F = int<em>0^t [ x(t) dt ] / int</em>0_T [ x(t) dt ]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_nim.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopNormalize-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T" href="#JetPack.JopNormalize-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopNormalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopNormalize(spc, c)</code></pre><p>where <code>F</code> is the &#39;normalize by maximuam value of integral&#39; operator F(t) = x(t) / int_0^T [ x(t) dt ] Note the integration is along the 1st (fastest) dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_normalize.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopPad-Union{Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Vararg{UnitRange,N} where N}} where T" href="#JetPack.JopPad-Union{Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Vararg{UnitRange,N} where N}} where T"><code>JetPack.JopPad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopPad(dom, pad..., [extend=false, accumulate=false])</code></pre><p>where <code>dom::JetSpace</code> is the domain of <code>A</code>, and <code>pad::UnitRange...</code> determines the range of <code>A</code>. If <code>extend=false</code>, then the padded region is set to zero.  If <code>extend=true</code>, then the padded region is set from the boundary of the domain.  The <code>accumulate=true</code> option is specific to the <code>Ginsu</code> operation in JetPackWave, and should not be used unless you really know what you are doing.</p><p><strong>Examples:</strong></p><p><strong>1D</strong></p><pre><code class="language-julia">A = JopPad(JetSpace(Float64,2), -1:3)
m = [1.0, 2.0]
d = A*m # d = [0.0, 0.0, 1.0, 2.0, 0.0]
A = JopPad(JetSpace(Float64,2), -1:3, extend=true)
d = A*m # d = [1.0, 1.0, 1.0, 2.0, 2.0]</code></pre><p><strong>2D</strong></p><pre><code class="language-julia">A = JopPad(JetSpace(Float64,2,2), -1:3, 1:3)
m = [11. 12. ; 21. 22.]
d = A*m # d = [0. 0. 11. 12. 0. ; 0. 0. 21. 22. 0. ; 0. 0. 0. 0. 0.]</code></pre><p><strong>Notes:</strong></p><ul><li>This operator may also be used for truncation</li><li>There may be overlap between the functionality of <code>JopPad</code> and <code>JopRestriction</code>, and it may be worth</li></ul><p>thinking of how to consolidate them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_pad.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopPermute-Tuple{Any,Any,Any}" href="#JetPack.JopPermute-Tuple{Any,Any,Any}"><code>JetPack.JopPermute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopPermute(sp, dims, perm)</code></pre><p>where <code>sp::JetSpace</code> is the domain and range of the operator, <code>dims::NTuple</code> is a tuple of dimensions that one wishes to permute, and <code>perm</code> is a tuple of arrays with permutation indices.</p><p><strong>Example 1:</strong></p><pre><code class="language-julia">A = JopPermute(JetSpace(Float64,4,2),(1,),([3;1;2;4],))
m = [11 12 ; 21 22 ; 31 32 ; 41 42]
d = A*m # d=[31 32 ; 11 12 ; 21 22 ; 41 42]</code></pre><p><strong>Example 2:</strong></p><pre><code class="language-julia">A = JopPermute(JetSpace(Float64,3,2),(1,2),([3;2;1],[2;1]))
m = [11 12 ; 21 22 ; 31 32]
d = A*m # d = [32 31 ; 22 21 ; 12 11]</code></pre><p><strong>Notes:</strong></p><p>Currently, this is only implmented for 1D, 2D and 3D arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_permute.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopPermutedims-Tuple{Any,Any}" href="#JetPack.JopPermutedims-Tuple{Any,Any}"><code>JetPack.JopPermutedims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopPermutedims(sp, perm)</code></pre><p>where <code>sp::JetSpace</code> is the domain of the operator, and <code>perm</code> is an array specifying the permutation of array dimensions.  The range of the operator is inferred from <code>sp</code> and <code>perm</code>.</p><p><strong>Example:</strong></p><pre><code class="language-julia">A = JopPermutedims(JetSpace(Float64,3,2),[2;1])
m = [1 2 3 ; 4 5 6]
d = A*m # d = [1 4 ; 2 5 ; 3 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_permutedims.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopPow-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}, Tuple{Jets.JetSpace{T,N} where N,Any,Any}} where T" href="#JetPack.JopPow-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}, Tuple{Jets.JetSpace{T,N} where N,Any,Any}} where T"><code>JetPack.JopPow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopPow(spc, c, a)</code></pre><p>where <code>F</code> is the power operator (x/c)^a with domain and range given by <code>spc::JetSpace</code>, and scalar values c, a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_pow.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopProjection-Union{Tuple{AbstractArray{T,N}}, Tuple{N}, Tuple{T}} where N where T" href="#JetPack.JopProjection-Union{Tuple{AbstractArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>JetPack.JopProjection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopProjection(u::AbstractArray)</code></pre><p><code>A*m</code> is the projection of vector <code>m</code> onto the vector <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_projection.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopReal-Union{Tuple{Jets.JetSpace{Complex{T},N} where N}, Tuple{T}} where T" href="#JetPack.JopReal-Union{Tuple{Jets.JetSpace{Complex{T},N} where N}, Tuple{T}} where T"><code>JetPack.JopReal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">op = JopReal(dom)</code></pre><p>Extract the real part of a complex input array where <code>dom::JetSpace{&lt;:Complex}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_real.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopReghost-Tuple{Jets.JetSSpace,Any,Any,Any,Any}" href="#JetPack.JopReghost-Tuple{Jets.JetSSpace,Any,Any,Any,Any}"><code>JetPack.JopReghost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopReghost(spc, zt, zm, dt, dx)</code></pre><p>Build a 2D receiver-side reghosting and redatuming operator in the FK domain using simple phase-shift operations (e.g. Posthumus, 1993).  <code>spc::JetSpaceSymmetric</code> is the domain and range of <code>A</code>. <code>zt</code> is target depth where the receivers will be re-dataumed to, and <code>zm</code> is the measurement depth where the recording is made. <code>dt</code> is the time sampling interval and <code>dx</code> is the receiver sampling interval.</p><p>Since this operator is built in the <strong>FK</strong> domain, <code>spc</code> has symmetry in the frequency dimension.  Hence <code>spc::JotSpaceSymmetric</code>.  We provide a convenience method:</p><pre><code class="language-none">sp = symspace(JopReghost, T, nw, nk)</code></pre><p>where <code>T</code> is either <code>Float32</code> or <code>Float64</code>, <code>nw</code> are the number of frequency samples, and <code>nk</code> are the number of wavenumber samples.</p><p><strong>Example:</strong></p><pre><code class="language-julia">P = JopPad(JetSpace(Float64,nt,nx), 1:2nt, 1:nx)
F = JopFft(range(P))
G = JopReghost(range(F), 20.0, 20.0, .004, 10.0)
A = P&#39;*F&#39;*G*F*P
data_reghost = A * data_noghost</code></pre><p>Note that in the above example,</p><pre><code class="language-julia">range(F) == symspace(JopReghost_df!, Float64, size(range(P))...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_reghost.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopRemoveDC-Union{Tuple{Jets.JetAbstractSpace{T,N}}, Tuple{N}, Tuple{T}} where N where T" href="#JetPack.JopRemoveDC-Union{Tuple{Jets.JetAbstractSpace{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>JetPack.JopRemoveDC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JopRemoveDC(s::JetAbstractSpace{T,N})</code></pre><p>F(x) = x - zero frequency component of x along the fastest dimension Uses Fourier transform, as the DC component differs from the mean as a function of interval length and zero padding. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_removedc.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopRestriction-Union{Tuple{T}, Tuple{Jets.JetAbstractSpace{T,N} where N,Array{T,1} where T}} where T" href="#JetPack.JopRestriction-Union{Tuple{T}, Tuple{Jets.JetAbstractSpace{T,N} where N,Array{T,1} where T}} where T"><code>JetPack.JopRestriction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopRestriction(dom[, rng], indices)</code></pre><p>Apply a restriction operator mapping from <code>dom::JetSpace</code> to <code>rng::JetSpace</code>, and using a one-dimensional array of indices where <code>indices</code> is one of:</p><ul><li><code>indices::Vector{Int,1}</code> - for restriction of 1-D arrays</li><li><code>indices::Vector{NTuple{N,Int}}</code> - for restriction of N-D arrays (N&gt;1)</li></ul><p>Note that in the case where the domain is N-dimension, the range is always stored using a 1-dimension array.</p><p><strong>example (1-D):</strong></p><pre><code class="language-julia">A = JopRestriction(JotSpace(Float64,4),[1,3])
m = [1.0;2.0;3.0;4.0]
d = A*m # d=[1.0;3.0]</code></pre><p><strong>example (2-D):</strong></p><pre><code class="language-julia">A = JopRestriction(JotSpace(Float64,2,2),[(1,2),(2,2)])
m = [1.0 2.0;3.0 4.0]
d = A*m # d=[2.0,4.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_restriction.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopRoughness-Tuple{Jets.JetSpace,Int64}" href="#JetPack.JopRoughness-Tuple{Jets.JetSpace,Int64}"><code>JetPack.JopRoughness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopRoughness(sp, dim, w)</code></pre><p><code>A</code>  can be used to regularize an optimization problem, applying a penalty to models that are non-smooth.  This is similar to a finite difference operator, but here no care is taken to ensure that <code>A</code> computes a derivative.  <code>dim</code> is the dimension that one wishes to smooth and <code>w</code> is the half-width of the smoother. The width of the window determines how strong the penalty is for being non-smooth.</p><p>For example, the form of <code>A</code> for <code>w=1</code> is,</p><pre><code class="language-julia">A=
[
(1/3-2/3) 1/3       0         0         ;
1/3       (1/3-3/3) 1/3       0         ;
0         1/3       (1/3-3/3) 1/3       ;
0         0         1/3       (1/3-2/3)
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_roughness.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopShift-Tuple{Jets.JetAbstractSpace,Any}" href="#JetPack.JopShift-Tuple{Jets.JetAbstractSpace,Any}"><code>JetPack.JopShift</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A = JopShift(spc, b) A = JopShift(b)</p><p>A(x) = x + b</p><p>where <code>spc::JetSpace</code> is the domain/range of <code>A</code>, and <code>b::Array</code> or <code>b::Number</code> is the affine translation or shift.  If <code>b&lt;:Number</code>, then shift is constant and one must specify <code>spc</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">A = JopShift(spc, b)</code></pre><p>where <code>spc::JetSpace</code> is the domain and range of <code>A</code>, and <code>b&lt;:Array</code> or <code>b&lt;:Number</code></p><pre><code class="language-julia">A = JopShift(b)</code></pre><p>where <code>b&lt;:AbstractArray</code>.  The domain and range of <code>A</code> are determined by the size and type of <code>b</code>.</p><pre><code class="language-julia">A = JopShift([1.0, 2.0, 3.0])
m = ones(domain(A))
d = A*m # d = [2.0 ; 3.0 ; 4.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_shift.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopSigmoid-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T" href="#JetPack.JopSigmoid-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T"><code>JetPack.JopSigmoid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">F = JopSigmoid(spc, c)</code></pre><p>where <code>F</code> is the sigmoid operator 1/(1+e^(-c/x)) with domain and range given by <code>spc::JetSpace</code>, and scalar value c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_sigmoid.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopTaper-Union{Tuple{M}, Tuple{Jets.JetAbstractSpace,Tuple{Vararg{Int64,M}},Tuple{Vararg{Real,M}},Tuple{Vararg{Real,M}}}} where M" href="#JetPack.JopTaper-Union{Tuple{M}, Tuple{Jets.JetAbstractSpace,Tuple{Vararg{Int64,M}},Tuple{Vararg{Real,M}},Tuple{Vararg{Real,M}}}} where M"><code>JetPack.JopTaper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopTaper(spc, dims, frac[, frac_end; mode=:normal, taper=(:cosine,:cosine)])</code></pre><p>The linear operator <code>A</code> tapers the edges of all or some subset of the dimensions of an array that belongs to <code>spc::JetSpace</code>.  The dimensions that are tapered are given by <code>dims</code>, an <code>Int</code> tuple. <code>A</code> will taper the beginning and/or end edges of each specified array dimension. The size of the beginning and end tapers are determined as a fraction of the length of that array dimension, and this fraction is set using the tuple <code>frac</code>, and (optionally) <code>frac_end</code>.</p><p>If <code>frac_end::NTuple{M,Float64}</code> is not set, then the ith entry of <code>frac::NTuple{M,Float64}</code> determines the length of the center portion of the ith dimension that is not tapered.  If <code>frac_end::NTuple{M,NTuple{2,Float64}}</code> is set, then the length of the begining taper of the ith array dimension is determiend by <code>frac[i]</code>, and the length of the end taper is determined by <code>frac_end[i]</code>.</p><p>The optional named argument <code>mode</code> can be used if the taper is applied to a dimension that corresponds to FFT ordering where the edges are assumed to be at the center and left ends of the dimension.</p><p>The optional named argument <code>taper</code> is a tuple specifying what type of taper to use at each end.  Available tapers are :cosine and :heaviside.</p><p><strong>Examples:</strong></p><p><strong>taper for a space containing 1D arrays</strong></p><pre><code class="language-julia">A = JopTaper(JetSpace(Float64,10), (1,), (.75,))
m = ones(domain(A))
d = A*m</code></pre><p><strong>taper for a space containing 1D arrays, and only taper at the end</strong></p><pre><code class="language-julia">A = JopTaper(JetSpace(Float64,10), (1,), (0.0,), (0.25,))
m = ones(domain(A))
d = A*m</code></pre><p><strong>taper for a space containing 2D arrays, where both dimensions are tapered</strong></p><pre><code class="language-julia">A = JopTaper(JetSpace(Float64,10,11), (1,2), (0.75,0.5))
m = ones(domain(A))
d = A*m</code></pre><p><strong>taper for a space containing 3D arrays, where two of the three dimensions are tapered</strong></p><pre><code class="language-julia">A = JopTaper(JetSpace(Float64,10,11,12), (1,3), (0.75,0.5))
m = ones(domain(A))
d = A*m</code></pre><p>In the next example, array dimension <code>1</code> is tapered at the end, and array dimension <code>2</code> is tapered at the beginning and end.</p><pre><code class="language-julia">A = JopTaper(JetSpace(Float64,10,11,12), (1,3), (0.0,0.25), (0.25,0.25))
m = ones(domain(A))
d = A*m</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_taper.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JetPack.JopTranslation-Union{Tuple{T}, Tuple{Array{T,2},Array{T,2}}} where T" href="#JetPack.JopTranslation-Union{Tuple{T}, Tuple{Array{T,2},Array{T,2}}} where T"><code>JetPack.JopTranslation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A = JopTranslation(p1::Matrix, p2::Matrix)</code></pre><p><code>A*m</code> translates <code>m::Matrix</code> using the vector field <code>(p1,p2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChevronETC/JetPack.jl/blob/c2b6cc43019d4ac2dd0dac3d2dbe46ad13717725/src/jop_translation.jl#L1-L5">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#JetPack.JopAtan-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T"><code>JetPack.JopAtan</code></a></li><li><a href="#JetPack.JopBlend"><code>JetPack.JopBlend</code></a></li><li><a href="#JetPack.JopCircShift-Tuple{Any,Any}"><code>JetPack.JopCircShift</code></a></li><li><a href="#JetPack.JopDerivative-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopDerivative</code></a></li><li><a href="#JetPack.JopDiagonal-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopDiagonal</code></a></li><li><a href="#JetPack.JopDifference"><code>JetPack.JopDifference</code></a></li><li><a href="#JetPack.JopExp-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T"><code>JetPack.JopExp</code></a></li><li><a href="#JetPack.JopGradient-Union{Tuple{N}, Tuple{T}, Tuple{Jets.JetSpace{T,N},Tuple{Vararg{T,N}}}} where N where T"><code>JetPack.JopGradient</code></a></li><li><a href="#JetPack.JopHighpass-Tuple{Jets.JetSpace}"><code>JetPack.JopHighpass</code></a></li><li><a href="#JetPack.JopImag-Union{Tuple{Jets.JetSpace{Complex{T},N} where N}, Tuple{T}} where T"><code>JetPack.JopImag</code></a></li><li><a href="#JetPack.JopInterp-Tuple{Jets.JetAbstractSpace,Jets.JetAbstractSpace}"><code>JetPack.JopInterp</code></a></li><li><a href="#JetPack.JopLMO-Union{Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any,Any,Any}} where T"><code>JetPack.JopLMO</code></a></li><li><a href="#JetPack.JopLaplacian-Tuple{Jets.JetSpace}"><code>JetPack.JopLaplacian</code></a></li><li><a href="#JetPack.JopLog-Tuple{Jets.JetSpace}"><code>JetPack.JopLog</code></a></li><li><a href="#JetPack.JopMix-Union{Tuple{N}, Tuple{T}, Tuple{Jets.JetAbstractSpace{T,N},Tuple{Vararg{Int64,N}}}} where N where T"><code>JetPack.JopMix</code></a></li><li><a href="#JetPack.JopNim-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopNim</code></a></li><li><a href="#JetPack.JopNormalize-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}} where T"><code>JetPack.JopNormalize</code></a></li><li><a href="#JetPack.JopPad-Union{Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Vararg{UnitRange,N} where N}} where T"><code>JetPack.JopPad</code></a></li><li><a href="#JetPack.JopPermute-Tuple{Any,Any,Any}"><code>JetPack.JopPermute</code></a></li><li><a href="#JetPack.JopPermutedims-Tuple{Any,Any}"><code>JetPack.JopPermutedims</code></a></li><li><a href="#JetPack.JopPow-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}, Tuple{Jets.JetSpace{T,N} where N,Any,Any}} where T"><code>JetPack.JopPow</code></a></li><li><a href="#JetPack.JopProjection-Union{Tuple{AbstractArray{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>JetPack.JopProjection</code></a></li><li><a href="#JetPack.JopReal-Union{Tuple{Jets.JetSpace{Complex{T},N} where N}, Tuple{T}} where T"><code>JetPack.JopReal</code></a></li><li><a href="#JetPack.JopReghost-Tuple{Jets.JetSSpace,Any,Any,Any,Any}"><code>JetPack.JopReghost</code></a></li><li><a href="#JetPack.JopRemoveDC-Union{Tuple{Jets.JetAbstractSpace{T,N}}, Tuple{N}, Tuple{T}} where N where T"><code>JetPack.JopRemoveDC</code></a></li><li><a href="#JetPack.JopRestriction-Union{Tuple{T}, Tuple{Jets.JetAbstractSpace{T,N} where N,Array{T,1} where T}} where T"><code>JetPack.JopRestriction</code></a></li><li><a href="#JetPack.JopRoughness-Tuple{Jets.JetSpace,Int64}"><code>JetPack.JopRoughness</code></a></li><li><a href="#JetPack.JopShift-Tuple{Jets.JetAbstractSpace,Any}"><code>JetPack.JopShift</code></a></li><li><a href="#JetPack.JopSigmoid-Union{Tuple{Jets.JetSpace{T,N} where N}, Tuple{T}, Tuple{Jets.JetSpace{T,N} where N,Any}} where T"><code>JetPack.JopSigmoid</code></a></li><li><a href="#JetPack.JopTaper-Union{Tuple{M}, Tuple{Jets.JetAbstractSpace,Tuple{Vararg{Int64,M}},Tuple{Vararg{Real,M}},Tuple{Vararg{Real,M}}}} where M"><code>JetPack.JopTaper</code></a></li><li><a href="#JetPack.JopTranslation-Union{Tuple{T}, Tuple{Array{T,2},Array{T,2}}} where T"><code>JetPack.JopTranslation</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« JetPack</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 5 July 2021 11:55">Monday 5 July 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
